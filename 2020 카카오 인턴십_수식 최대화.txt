// 2020 카카오 인턴십 : 수식 최대화 (문자열 + 구현)
#include <string>
#include <vector>
#include <queue>

using namespace std;

// 가능한 연산자 우선순위 경우의 수를 저장
vector<vector<string>> op_priority = {
    {"+", "-", "*"},
    {"+", "*", "-"},
    {"-", "+", "*"},
    {"-", "*", "+"},
    {"*", "+", "-"},
    {"*", "-", "+"} 
};

long long solution(string expression) {
    long long answer = 0;

    queue<string> exp;

    // 숫자와 연산자를 분리해 큐에 삽입
    int opNum = 0; // operator의 개수를 저장
    string num;
    for (int i = 0; i < expression.size(); i++) {
        if (expression[i] < '0' || expression[i] > '9') { // 숫자가 아니라면
            opNum++;
            
            exp.push(num);
            num = ""; // num 초기화
            
            string op;
            op += expression[i];
            exp.push(op);

            continue;
        }

        num += expression[i];
    }
    exp.push(num);

    long long maxResult = 0; // 결과값의 최댓값을 저장
    for (int i = 0; i < 6; i++) { // 경우의 수 6가지

        // 초기화
        queue<string> q = exp;
        int cnt = opNum;

        for (int j = 0; j < 3; j++) { // 연산자의 개수 3가지

            string num1 = q.front();
            q.pop();

            for (int z = cnt; z > 0; z--) { // 수식에 남아있는 연산자의 개수

                string op = q.front();
                q.pop();

                // 계산할 대상이 되는 연산자가 아니라면
                if (op != op_priority[i][j]) {
                    q.push(num1);
                    q.push(op);

                    num1 = q.front();
                    q.pop();

                    continue;
                }
              
                // 계산할 대상이 되는 연산자라면
                string num2 = q.front();
                q.pop();

                // 계산 (stoi()가 아니라 stoll()을 사용해야 함)
                if (op == "+") num1 = to_string(stoll(num1) + stoll(num2));
                else if (op == "-") num1 = to_string(stoll(num1) - stoll(num2));
                else if (op == "*") num1 = to_string(stoll(num1) * stoll(num2));

                cnt--;
            }

            q.push(num1);
        }

        // 결과값의 최댓값 갱신
        long long result = abs(stoll(q.front()));
        if (result > maxResult) maxResult = result;
    }

    // 답안 갱신
    answer = maxResult;
    return answer;
}