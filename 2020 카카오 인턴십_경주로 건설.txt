// 2020 카카오 인턴십 : 경주로 건설 (BFS + DP)
#include <string>
#include <vector>
#include <queue>

using namespace std;

int INF = 500000000; // 임의의 큰 값

// 움직임을 정의
int dy[4] = { 0, 0, 1, -1 };
int dx[4] = { 1, -1, 0, 0 };

int price[25][25][4]; // 각 좌표까지의 진행방향에 따른 경주로 건설 최소 비용

int solution(vector<vector<int>> board) {
    int answer = 0;

    int n = board.size(); // 부지의 크기

    // 비용 초기화
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < 4; k++) { // 각 좌표에 도달했을 때의 진행 방향
                price[i][j][k] = INF;
            }
        }
    }

    int minPrice = INF; // 최소 건설 비용

    queue<vector<int>> q; // {y, x, dir};
    q.push({ 0, 0, 0});
    q.push({ 0, 0, 1});
    q.push({ 0, 0, 2});
    price[0][0][0] = 0;
    price[0][0][1] = 0;
    price[0][0][2] = 0;

    while (!q.empty()) {
        int y = q.front()[0];
        int x = q.front()[1];
        int dir = q.front()[2];
        q.pop();

        // 도착점까지 계산을 완료 했다면
        if (y == n - 1 && x == n - 1) {
            // 최소 건설 비용 갱신
            if (price[y][x][dir] < minPrice) minPrice = price[y][x][dir];
            continue;
        }

        for (int i = 0; i < 4; i++) {
            int nxtY = y + dy[i];
            int nxtX = x + dx[i];

            // 부지 밖의 영역이라면
            if (0 > nxtY || nxtY >= n || 0 > nxtX || nxtX >= n) continue;

            // 벽이라면
            if (board[nxtY][nxtX]) continue;

            int estimatedPrice = price[y][x][dir] + 100;
            if (i != dir) {
                estimatedPrice += 500;
            }

            if (estimatedPrice < price[nxtY][nxtX][i]) {
                q.push({ nxtY, nxtX, i });
                price[nxtY][nxtX][i] = estimatedPrice;
            }
        }
    }

    // 답안 갱신 
    answer = minPrice;

    return answer;
}