// 2017 카카오코드 본선 : GPS (DP)
#include <vector>
#include <algorithm>

using namespace std;

// dp[시각][해당 시각에 지나는 거점] = 그 때 까지의 수정 횟수
int dp[100][201]; // 시각 : 0~(k-1), 노드 번호 : 1~n
int INF = 2000000000; // 임의의 큰 값

// 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.
int solution(int n, int m, vector<vector<int>> edge_list, int k, vector<int> gps_log) {
    int answer = -1;

    vector<vector<int>> graph(n + 1); // 그래프 정보를 저장
    // 주어진 간선정보를 이용하여 그래프를 그림
    for (int i = 0; i < m; i++) {
        // 양방향 그래프
        graph[edge_list[i][0]].push_back(edge_list[i][1]);
        graph[edge_list[i][1]].push_back(edge_list[i][0]);
    }

    // dp 초기화
    for (int i = 0; i < k; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = INF;
        }
    }

    // 시작 노드는 수정할 수 없다,
    dp[0][gps_log[0]] = 0;

    for (int t = 1; t < k; t++) { // 시각
        for (int x = 1; x <= n; x++) { // 시각에 지나는 노드
            // 이전노드로 부터 이동하지 않는 경우 (이전 시각에 현재의 노드였는지 확인) 
            dp[t][x] = min(dp[t][x], dp[t - 1][x] + (gps_log[t] == x ? 0 : 1));

            // 인접노드로 부터 이동한 경우 (이전 시각에 인접한 노드였는지 확인)
            for (int i = 0; i < graph[x].size(); i++) {
                int y = graph[x][i]; // 인접노드
                dp[t][x] = min(dp[t][x], dp[t - 1][y] + (gps_log[t] == x ? 0 : 1));
            }
        }
    }

    // 답안 갱신 
    if (dp[k - 1][gps_log[k - 1]] != INF) answer = dp[k - 1][gps_log[k - 1]];

    return answer;
}