// 2017 카카오코드 예선 : 보행자 천국 (BFS + DP)
#include <vector>
#include <queue>

using namespace std;

int MOD = 20170805;

// 자동차의 움직임을 정의 (오른쪽, 아래쪽)
int dy[2] = { 0, 1 };
int dx[2] = { 1, 0 };

int dp[500][500][2]; // 각 좌표까지의 경로의 수와 그때의 진행방향을 저장
bool finished[500][500][2]; // 탐색이 끝난 좌표와 진행방향을 저장

// 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.
int solution(int m, int n, vector<vector<int>> city_map) {
    int answer = 0;

    // dp, finished 초기화
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            for (int k = 0; k < 2; k++) {
                dp[i][j][k] = 0;
                finished[i][j][k] = false;
            }
        }
    }

    // BFS 알고리즘 사용
    queue<vector<int>> q;
    q.push({ 0, 0, 0 }); // {y, x, dir}
    dp[0][0][0] = 1;

    while (!q.empty()) {
        int y = q.front()[0];
        int x = q.front()[1];
        int dir = q.front()[2];
        q.pop();

        // 이미 탐색이 종료된 좌표라면
        if (finished[y][x][dir]) continue;

        for (int i = 0; i < 2; i++) {
            int nxtY = y + dy[i];
            int nxtX = x + dx[i];

            // 지도 밖의 영역이라면
            if (0 > nxtY || nxtY >= m || 0 > nxtX || nxtX >= n) continue;

            // 자동차 통행이 금지되어 있다면
            if (city_map[nxtY][nxtX] == 1) continue;

            // 현재 좌표가 보행자 안전 구역인데 좌우 회전이 필요하다면
            if (city_map[y][x] == 2 && i != dir) continue;

            q.push({ nxtY, nxtX, i });
            dp[nxtY][nxtX][i] += (dp[y][x][dir] % MOD);
        }

        finished[y][x][dir] = true;
    }

    // 답안 갱신
    answer = (dp[m - 1][n - 1][0] + dp[m - 1][n - 1][1]) % MOD;
    return answer;
}